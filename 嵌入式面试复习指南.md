# 嵌入式开发面试复习2.26

> 涵盖 C 语言基础、STM32 单片机、FreeRTOS 实时操作系统及项目实战经验

---

## 目录

1. [C 语言基础](#一c-语言基础)
2. [STM32 单片机](#二stm32-单片机)
3. [FreeRTOS 实时操作系统](#三freertos-实时操作系统)
4. [Linux 基础](#四linux-基础)
5. [项目开发流程](#五项目开发流程)
6. [项目实战](#六项目实战)
   - 6.1 [小智 AI 语音聊天机器人](#61-小智-ai-语音聊天机器人)
   - 6.2 [智能门铃](#62-智能门铃)
   - 6.3 [智能门锁](#63-智能门锁)
   - 6.4 [无人机飞控](#64-无人机飞控)
   - 6.5 [牛羊定位器](#65-牛羊定位器)
   - 6.6 [STM32 网关](#66-stm32-网关)
   - 6.7 [步进电机控制](#67-步进电机控制)

---

## 一、C 语言基础

### 1.1 源码到可执行文件的过程

| 阶段 | 功能 | 输出 |
|------|------|------|
| **预处理** | 执行预处理指令、去掉空格注释、宏替换 | 预处理后的源码 `.i` |
| **编译** | 预处理后的源文件 → 汇编文件 | `.s` 汇编文件 |
| **汇编** | 汇编文件 → 二进制目标文件 | `.o` 目标文件 |
| **链接** | 多个目标文件和库文件链接成可执行文件 | 可执行二进制文件 |

### 1.2 C 语言内存模型

```
高地址
+------------------+
|      栈区        |  ← 局部变量、函数参数（向下增长）
+------------------+
|      堆区        |  ← 动态分配内存（malloc/free，向上增长）
+------------------+
|    全局静态区     |  ← 全局变量、静态局部变量、字符串常量
|   (数据区)       |      - 未初始化区（BSS）
|                  |      - 初始化区
+------------------+
|   文本段(代码段)  |  ← 函数体的二进制指令
+------------------+
低地址
```

#### 堆和栈的区别

| 特性 | 堆 | 栈 |
|------|------|------|
| **申请方式** | 程序员手动申请（malloc/calloc） | 编译器自动分配 |
| **生长方向** | 从低地址向高地址增长（↑） | 从高地址向低地址增长（↓） |
| **效率** | 较慢（需要查找空闲块） | 较快（直接移动指针） |
| **碎片问题** | 容易产生碎片 | 无碎片 |
| **面向对象** | 面向用户 | 面向操作系统 |
| **生命周期** | 由程序员控制 | 由函数控制 |
| **大小限制** | 较大（受限于虚拟内存） | 较小（默认几MB） |

#### 如何避免堆栈溢出？

- 及时 `free` 释放内存
- 递归层次不要过深
- 传参尽可能传指针，不要传递过大的对象

### 1.3 32/64 位系统的地址长度

- **32 位系统**：地址长度 4 字节
- **64 位系统**：地址长度 8 字节

### 1.4 变量的声明与定义

```c
// 声明：告诉编译器变量的类型和名称
int a;

// 定义：分配内存并初始化
int a = 10;
```

### 1.5 变量与常量

| 特性 | 变量 | 常量 |
|------|------|------|
| 值的可变性 | 可随时修改 | 只能赋值一次，不可随意修改 |
| 修饰符 | 无 | `const`、`#define` |

变量的值可以修改，常量的值不能修改。

变量通常在运行时分配内容，常量通常在编译时分配内容。



### 1.6 常量定义方式对比

| 特性 | `const` | `#define` |
|------|---------|-----------|
| 引入标准 | C99 | 传统宏定义 |
| 类型检查 | 有，类型安全 | 无，纯文本替换 |
| 作用域 | 有作用域 | 无作用域 |
| 内存分配 | 可能分配内存 | 不分配内存 |
| 调试 | 方便 | 困难 |

> **习惯用法**：`#define` 更常用，方便全局宏替换

### 1.7 全局变量与局部变量

| 特性 | 全局变量 | 局部变量 |
|------|----------|----------|
| **作用域** | 整个程序 | 声明它的代码块内（当前函数） |
| **定义位置** | 函数外部 | 函数内部 |
| **生命周期** | 整个程序运行期间 | 函数执行期间 |
| **存储位置** | 全局静态区 | 栈 |
| **默认初始化** | 自动初始化为 0 | 随机值（脏数据） |

### 1.8 预处理指令

```c
#include    // 包含头文件
#define     // 宏定义
#if / #ifdef / #ifndef / #endif   // 条件编译
#undef      // 取消宏定义
#if	//如果表达式为真
#ifdef	//如果宏已定义
#ifndef	//如果宏未定义
#else	//否则
#elif	//否则如果
#endif	//结束条件编译
```

| 指令       | 含义             | 示例               |
| ---------- | ---------------- | ------------------ |
| `#include` | 包含头文件       | `#include `        |
| `#define`  | 定义宏           | `#define PI 3.14`  |
| `#undef`   | 取消宏定义       | `#undef PI`        |
| `#ifdef`   | 如果宏**已定义** | `#ifdef DEBUG`     |
| `#ifndef`  | 如果宏**未定义** | `#ifndef DEBUG`    |
| `#if`      | 条件判断         | `#if LEVEL > 1`    |
| `#else`    | 否则             | `#else`            |
| `#elif`    | 否则如果         | `#elif LEVEL == 2` |
| `#endif`   | 结束条件块       | `#endif`           |



### 1.9 条件编译的应用场景

1. **调试代码**：通过宏开关控制调试信息输出
   
    发布版本只需注释 `#define DEBUG`，所有调试代码都不会编译进去，不占用程序空间。 
   
   ```c
   #define DEBUG
   #ifdef DEBUG
    printf("debug info\n");
   #endif
   ```
   
2. **功能开关**：选择性编译某些功能模块（如 FreeRTOSConfig.h）

3. **跨平台编译**：针对不同平台(win/linux)编译不同代码

### 1.10 数据类型

#### 内置类型

| 类型 | 说明 |
|------|------|
| `char` | 字符型（8位整数，ASCII码）   1 |
| `short` | 短整型   2 |
| `int` | 整型    4 |
| `long` | 长整型（armcc 编译器下 4 字节）  4 |
| `long long` | 长长整型（C99）   8 |
| `float` | 单精度浮点   4 |
| `double` | 双精度浮点    8 |
| `unsigned xxx` | 无符号版本 |

char 本质 长度为1个字节的整数，实际存储的是字符对应的ascii的编码值



#### 自定义类型

- **结构体**（`struct`）：封装多个不同类型的数据
- **共用体**（`union`）：所有成员共享同一块内存
- **枚举**（`enum`）：定义具名常量集合（代码阅读性更好，类型更安全）

### 1.11 整型和浮点型存储原理

#### 整型存储（补码形式）

```
正数 8：0000 1000
负数 -8：
    原码：1000 1000
    反码：1111 0111
    补码：1111 1000（反码 + 1）
```

> **优势**：节省底层硬件电路，使用加法电路实现减法

#### 浮点型存储

```
符号位(1位) + 指数位(8位float/11位double) + 尾数位

符号位：1表示负数，0表示正数
指数位：科学计数法中的指数（偏移量存储）
尾数位：只存储小数点后的值
```

### 1.12 自动类型转换原则

#### 整数转换

- 窄类型 → 宽类型
- 有符号 → 无符号

#### 浮点数转换
- `float` → `double`

#### 整数与浮点数
- 整数 → 浮点数

### 1.13 num++ vs ++num

```c
int i = 1;

// i++：先取值，后自增
int a = i++;  // a = 1, i = 2

// ++i：先自增，后取值
int b = ++i;  // i = 3, b = 3

// 经典面试题
printf("%d %d", i++, i++);  // 结果取决于编译器实现（未定义行为）
```

| 表达式 | 说明 |
|--------|------|
| `i++` | 后置自增：先返回原值，再自增 |
| `++i` | 前置自增：先自增，再返回新值 |

### 1.14 `typedef` vs `#define`

| 特性 | `typedef` | `#define` |
|------|-----------|-----------|
| 本质 | 关键字，创建真正的类型别名 | 预处理器文本替换 |
| 类型检查 | 有 | 无 |
| 作用域 | 有 | 无 |
| 安全性 | 更安全 | 缺乏安全性 |

### 1.14 控制语句

#### switch 语句

```c
switch (整型变量) {  // 只能是整数类型或枚举
    case 1: ...; break;
    case 2: ...; break;
    default: ...;
}
```

#### break 与 continue

| 语句 | 循环中作用 | switch 中作用 |
|------|-----------|---------------|
| `break` | 结束最内层循环 | 防止 case 穿透 |
| `continue` | 结束本轮循环，进入下一轮 | 不适用 |

### 1.15 数组

#### 特点

- 内存连续存储（不连续的是链表）
- 长度固定（定义时确定）
- 通过下标或指针访问

#### 数组长度计算

```c
int arr[10];
int length = sizeof(arr) / sizeof(arr[0]);  // 40/4 = 10
sizeof(arr) 是是数组总字节数
length 算出来是元素个数
```

#### 多维数组

```c
int arr[2][3];  // 数组的元素还是数组

// C语言中多维数组在内存中是连续存储的
// arr[2][3] 内存布局：
// arr[0][0] arr[0][1] arr[0][2] arr[1][0] arr[1][1] arr[1][2]
```

### 1.16 字符串

- **本质**：以 `'\0'` 结尾的字符数组

#### `sizeof` vs `strlen`

| 函数 | 计算内容 | 是否包含 `'\0'` |
|------|----------|-----------------|
| `sizeof` | 数组总大小（字节） | 包含 |
| `strlen` | 字符串实际长度 | 不包含 |

### 1.17 指针

#### 指针运算

| 运算 | 说明 | 结果 |
|------|------|------|
| 指针 - 指针 | 计算两个指针间的元素距离（元素个数） | 整数（元素个数） |
| 指针 + 指针 | **没有意义** | - |
| 指针 ± 整数 | 指针移动 | 新地址 |
| 指针比较 | 比较地址值 | 布尔值 |

> **注意**：指针相加没有实际意义，只有相减才能计算元素距离。

#### 指针与数组名的区别

- **数组名**：常量指针，不可修改，代表数组首地址
- **指针变量**：可以修改指向

#### 指针数组 vs 数组指针

```c
int *p[10];    // 指针数组：数组，存储 10 个 int* 指针
int (*p)[10];  // 数组指针：指针，指向一个包含 10 个 int 的数组
```

#### 指针函数 vs 函数指针

```c
int *func(int a, int b);   // 指针函数：返回 int* 的函数  返回值是指针的函数(注意不能返回局部变量地址)
int (*func)(int a, int b); // 函数指针：指向函数的指针
```

#### 常量指针 vs 指针常量

```c
const int *p;    ( 定义指针，const)
				// 常量指针：指向常量的指针   不能修改指向的值(常量)
                // *p = 10;  // 错误：不能修改指向的值 
                // p = &a;   // 正确：可以修改指向

int *const p;  (定义一个常量为指针)
				// 指针常量：指针本身是常量  不能修改指向的地址(可以改指向地址的值)
                // *p = 10;  // 正确：可以修改指向的值
                // p = &a;   // 错误：不能修改指向
```

#### 特殊指针

| 类型 | 定义 | 危害 |
|------|------|------|
| **空指针** | `NULL`（地址 0）指向无效地址 | 访问会崩溃（可控） |
| **悬空指针** | 指向已释放内存的指针(内存已释放，但指针还保留原地址) | 不可预测的行为**不可预测**，可能崩溃、可能读到垃圾值、可能正常 |
| **野指针** | 未初始化的指针.未初始化，指向未知内存 | 不可预测的行为 |

```c
// 悬空指针示例
int *a = malloc(100);
free(a);  // a 变成悬空指针
// 正确做法：free(a) 后 a = NULL;
```

#### 指针和引用的区别（C++）

```c
int a = 3;
int &ra = a;  // 引用是变量的别名

// 区别：
// 1. 指针可以不初始化，引用必须初始化（唯一绑定不可更改）
// 2. 操作引用就是直接操作值，引用直接和内存的值绑定
```

### 1.18 结构体与共用体

#### 访问方式

```c
struct Person p;
struct Person *ptr = &p;

p.name;      // 结构体变量访问成员
ptr->name;   // 结构体指针访问成员
```

#### 内存对齐

1. **结构体本身对齐**：地址是最大成员长度的倍数
2. **成员对齐**：每个成员按自身大小对齐（合理节省内存占用）

```c
// 示例
struct {
    char a;   // 1字节 + 3字节填充
    int b;    // 4字节
    short c;  // 2字节 + 2字节填充
};  // 总大小：12字节
```

#### 函数中传入结构体还是结构体指针？

| 方式 | 栈空间 | 修改外部 |
|------|--------|----------|
| 传值 | 变大 | 不影响 |
| 传指针 | 较小 | 会影响 |

> **建议**：一般使用结构体指针，栈占用空间少

#### 结构体 vs 共用体

| 特性 | 结构体（`struct`） | 共用体（`union`） |
|------|-------------------|-------------------|
| 内存分配 | 每个成员独立内存 | 所有成员共享同一块内存 |
| 大小 | 所有成员大小之和（考虑对齐） | 最大成员的大小 |
| 用途 | 封装相关数据 | 节省内存，多态场景 |

### 1.19 函数

#### 形参与实参

| 概念 | 说明 |
|------|------|
| **形参** | 函数声明/定义时的参数 |
| **实参** | 函数调用时传入的参数 |

#### 主函数参数

```c
int main(int argc, char *argv[]) {
    // argc: 参数个数（包含程序名）
    // argv: 参数数组
    // 示例：./hello a b c
    // argc = 4, argv = ["hello", "a", "b", "c"]
    return 0;  // 返回值表示程序退出状态
}
```

主函数可以不带任何参数。这是最常见的形式。

可以设置两个形参：argc（argument count）和argv（argument vector）。这主要用于处理命令行参数。

（1）argc：参数的数量。它至少为1，因为第一个参数是程序的名称。

（2）argv：一个由字符指针组成的指针数组，每个指针指向一个命令行参数的字符串。

返回值0表示运行成功，其它非零整数表示运行失败。

#### 函数原型

只有签名，没有实现的函数声明：

```c
void func(int a, int b);  // 函数原型
```

#### 传递方式对比

| 方式 | 特点 | 适用场景 |
|------|------|----------|
| **传值** | 复制数据，函数内修改不影响外部 | 小数据量 |
| **传指针** | 传递地址，可修改原数据 | 大数据、需要修改原数据 |

#### 回调函数

函数指针作为参数，实现函数的动态调用。

```c
// 定义函数指针类型
typedef void (*CallbackFunc)(int);

// 注册回调函数
void registerCallback(CallbackFunc cb);

// 应用场景：MQTT客户端回调、蓝牙回调
```

#### 带参宏 vs 函数

| 特性 | 带参宏 | 函数 |
|------|--------|------|
| 执行时机 | 编译时文本替换 | 运行时调用 |
| 类型检查 | 无 | 有 |
| 调试 | 困难 | 容易 |
| 代码体积 | 可能膨胀 | 固定 |

#### 内联函数（`inline`）

```c
inline void func() {
    // 一行或几行简单代码
    // 建议编译器将函数体直接插入调用处，减少调用开销
}
```

#### 常用输出函数

| 函数 | 功能 | 示例 |
|------|------|------|
| `printf` | 标准输出（控制台） | `printf("%d", a)` |
| `sprintf` | 输出到字符串 | `sprintf(buf, "%d", a)` |
| `fprintf` | 输出到文件 | `fprintf(file, "%d", a)` |

#### 常用内存函数

| 函数 | 功能 |
|------|------|
| `malloc` | 动态分配内存（不初始化） |
| `calloc` | 动态分配内存（初始化为0） |
| `realloc` | 重新分配内存大小 |
| `free` | 释放内存 |
| `memset` | 设置内存值 |
| `memcpy` | 内存拷贝 |
| `memmove` | 内存移动（支持重叠） |

#### malloc vs calloc

```c
// malloc: 分配指定字节数，内容未初始化（垃圾值）
void *malloc(size_t size);
int *p1 = malloc(10 * sizeof(int));  // 分配 40 字节

// calloc: 分配并初始化为 0
void *calloc(size_t num, size_t size);
int *p2 = calloc(10, sizeof(int));   // 分配 40 字节，全部初始化为 0
```

| 特性 | malloc | calloc |
|------|--------|--------|
| **参数** | 单个参数（总字节数） | 两个参数（元素个数 + 每个元素大小） |
| **初始化** | 不初始化，内容是垃圾值 | 自动初始化为 0 |
| **效率** | 稍快（不做初始化） | 稍慢（需要清零） |
| **适用场景** | 即将覆盖写入的数据 | 需要零初始化的数组、结构体 |

**等价关系**：
```c
// calloc(n, size) 等价于:
malloc(n * size) + memset(ptr, 0, n * size)
```

### 1.20 关键字

#### `static`

| 用法 | 作用 |
|------|------|
| **全局变量/函数** | 限制作用域在当前文件（内部链接） |
| **局部变量** | 生命周期延长到整个程序运行期间，只初始化一次，存储在全局静态区 |

#### `extern`

声明外部变量，表示变量在其他文件中定义。

```c
extern int globalVar;  // 声明外部变量
```

#### `volatile`

防止编译器优化，强制每次从内存读取变量值。

```c
volatile int flag;  // 可能用于多线程或硬件寄存器
// 嵌入式中常见：__IO, __I, __O
```

**原理**：CPU每次读取都去内存读取访问最新值，而不是从寄存器缓存读取。

### 1.21 内存相关

#### 虚拟内存

> **问题**：1G 物理内存能否 `malloc(1.2G)`？
> 
> **答案**：能。通过虚拟内存机制（MMU），操作系统可以提供比物理内存更大的地址空间。将暂时不运行的进程 swap 到磁盘中。

#### 内存泄漏

```c
// 错误示例1：指针覆盖
int *a = malloc(100);
a = malloc(200);  // 第一次分配的 100 字节丢失，无法释放

// 错误示例2：指针置空后无法释放
int *a = malloc(100);
a = NULL;  // 原内存地址丢失，造成泄漏
// free(a);  // 无效，无法释放原内存
```

**预防措施**：
- 及时 `free` 释放不再使用的内存
- `free` 后立即将指针置为 `NULL`
- 使用内存检测工具（如 Valgrind）

#### 内存溢出（OOM）

直接报错，系统内存不足。当申请的内存超过系统可用内存时发生。

---

## 二、STM32 单片机

### 2.1 指令集架构

| 类型 | 代表 | 特点 |
|------|------|------|
| **CISC（复杂指令集）** | x86 | 指令多、变长、复杂 |
| **RISC（精简指令集）** | ARM、RISC-V | 指令少、定长、简单 |

### 2.2 CPU 架构组成

| 组成部分 | 功能 |
|----------|------|
| **CU（控制单元）** | 将指令转化为控制电信号，控制寄存器和ALU加载计算 |
| **ALU（算术逻辑单元）** | 逻辑运算单元 |
| **MMU（内存管理单元）** | 虚拟内存映射 |
| **寄存器** | 通用寄存器、状态寄存器、程序计数器 |

### 2.3 ARM 处理器分类

| 系列 | 特点 | 应用场景 |
|------|------|----------|
| **A 系列** | 高性能 | 手机、平板、电视、机器人、医疗、车载 |
| **R 系列** | 实时性 | 汽车、医疗、车载 |
| **M 系列** | 嵌入式 | 传感器、智能家居 |

### 2.4 存储器类型

| 类型 | 全称 | 特点 |
|------|------|------|
| **ROM** | Read-Only Memory(flash ) | 只读，掉电不丢失（磁盘） |
| **RAM** | Random Access Memory | 随机读写，掉电丢失（内存） |
| **Register** | 寄存器 | CPU 内部，速度最快 |

#### 特点对比

容量：Register < RAM < ROM  
效率：Register > RAM > ROM  
价格：Register > RAM > ROM		

#### SRAM vs DRAM vs SDRAM

| 类型 | 特点 |
|------|------|
| **SRAM** | 静态 RAM，速度快，无需刷新，贵，用于 CPU L级缓存 |
| **DRAM** | 动态 RAM，需周期性刷新，便宜，用于内存条 |
| **SDRAM** | 同步 DRAM，与系统时钟同步，效率比 DRAM 稍高 |

| 存储器       | 存放内容       | 掉电   | 读写速度 |
| ------------ | -------------- | ------ | -------- |
| **Flash**    | 程序代码、常量 | 不丢失 | 较慢     |
| **RAM/SRAM** | 变量、堆栈     | 丢失   | 很快     |
| **EEPROM**   | 用户数据       | 不丢失 | 慢       |

 Flash 确实慢，但通过预取、缓存等技术，实际执行效率已经足够高。 

```
┌─────────────────────────┐
│   ARM Cortex-M3 内核     │  ← CPU核心
├─────────────────────────┤
│       总线矩阵           │  ← 数据交换中心
├─────────────────────────┤
│   Flash  │  外设  │ SRAM │  ← 存储/外设
├──────────┴──────────────┤
│  GPIO │ USART │ IIC ... │  ← 具体外设
├─────────────────────────┤
│      STM32F10X 芯片      │
└─────────────────────────┘

Flash → 硬盘（程序存储）
SRAM  → 内存条（数据存储）

```



### 2.5 字节序（Endianness）

#### 定义

多字节数据在内存中的存储顺序。

```c
int a = 1;  // 0x00000001

// 小端序（Little Endian）：低地址存低位
// 内存：00 00 00 01（低地址 → 高地址）

// 大端序（Big Endian）：低地址存高位
// 内存：01 00 00 00（低地址 → 高地址）
```

#### 常见架构

| 架构 | 字节序 |
|------|--------|
| x86 | 小端序 |
| ARM | 小端序（可配置） |

#### 判断字节序的方法 判断大小端

**方法 1：指针法** 取第一个字节判断

```c
int a = 1;   //0x00000001
if (*(char *)&a == 1)
    printf("小端序\n");
else
    printf("大端序\n");
// 小端序内存布局（低地址 → 高地址）:
// 地址: 0x1000  0x1001  0x1002  0x1003
// 数据:   01      00      00      00

// 大端序内存布局（低地址 → 高地址）:
// 地址: 0x1000  0x1001  0x1002  0x1003
// 数据:   00      00      00      01
*(char *)&a
│    │   │
│    │   └── int a 的地址（指向4字节）
│    └────── 强制转为 char*（只取1字节）
└─────────── 解引用，读取第一个字节
    
字节序	第一个字节	结果
小端序	0x01	== 1 ✓
大端序	0x00	!= 1
```

**方法 2：共用体法**

```c
//共享内存 访问低字节
union {
    int a;
    char b;
} c;
c.a = 1;
if (c.b == 1)
    printf("小端序\n");
else
    printf("大端序\n");
 	// 0x00 00 00 01
    // union使用同一块内存，char从最低地址开始
```

### 2.6 最小系统

STM32单片机能工作的最小外围电路就叫最小系统。

STM32 最小系统组成： 

1. **芯片**
2. **晶振**（外部高速/低速晶振）
3. **电源**电路
4. **复位**电路
5. **下载**电路（SWD/JTAG）

> 定义：能让单片机运行起来的最小外围电路

STM32的外设有哪些

I2C、SPI、ADC、UART、CAN、TIM、独立看门狗（IWDG）、RTC。

### 2.7 复位后 main 函数执行前的操作

1. **复位向量**：程序计数器（PC）跳转到复位向量地址（存在中断向量表）
2. **执行启动代码**：汇编写的启动文件，负责基本硬件初始化
3. **堆栈指针初始化**
4. **系统时钟初始化**
5. **数据段初始化**
6. **C库初始化**：初始化C库所需的内部数据结构
7. **执行 main 函数**

### 2.8 中断

#### 概念

CPU 处理突发事件的一种能力。

CPU 对系统发生某事件时的一种响应

CPU 暂停正在执行的程序，在保留现场后，自动地转去执行该事件的中断处理程序，执行完后，再返回到原程序的断点处继续执行。

#### 中断向量 

中断处理程序入口地址。

#### 中断向量表

存放中断码、中断处理程序入口地址的一段内存空间

存储各个中断服务程序入口地址的一段内存（指针数组，存储不同中断的函数指针）。、

  存放中断服务函数入口地址的一张"地址表"

#### 中断处理过程

```
中断事件发生 → 保存现场 → 响应中断 → 恢复现场 → 中断返回
```

#### 中断嵌套

高优先级中断可以打断低优先级中断的执行。

#### 中断服务函数特点

| 特性 | 说明 |
|------|------|
| 参数 | 无 |
| 返回值 | 无 |
| 调用方式 | 硬件自动调用 |
| 命名 | 固定（与向量表对应） |
| 递归 | 不可递归 |
| 耗时操作 | 应避免 |

#### 中断服务函数优化（执行时间过长）

 推迟执行

**问题**：执行时间过长会阻塞系统。

**解决方案**：

| 场景 | 方法 |
|------|------|
| **裸机** | 中断设置标志位，主循环轮询处理 |
| **RTOS** | 中断发送信号/通知，任务处理 |

**中断推迟处理实现**：
- 裸机：中断修改标志位，main函数轮询标志位
- FreeRTOS：中断向阻塞任务发送任务通知，任务接受通知从阻塞状态唤醒

#### 中断优先级分组

支持多种分组方式（3、4、5、6、7 位用于抢占优先级）。

分为组0~5，组号表示抢占优先级可设置的位数，抢占 + 响应 = 4位。

|               | ***\*抢占优先级\**** | ***\*响应优先级\**** |
| ------------- | -------------------- | -------------------- |
| ***\*组0\**** | 0位（0）             | 4位                  |
| ***\*组1\**** | 1位（0~1）           | 3位                  |
| ***\*组2\**** | 2位（0~3）           | 2位                  |
| ***\*组3\**** | 3位（0~7）           | 1位                  |
| ***\*组4\**** | 4位（0~15）          | 0位                  |

**相比于正常函数，中断服务函数有什么特点和需要注意的地方？** 

对于中断服务函数：

（1）没有参数和返回值。

（2）需要配置相应的寄存器来开启中断。

（3）触发条件满足时，硬件自动调用。

（4）内部不能递归调用自己。

（5）尽量不要执行耗时操作。

### 2.9 GPIO  **General Purpose Input/Output（通用输入输出）** 

GPIO是通用输入输出，STM32的一种重要的外设，可以用于控制数字输入输出

```
功能：
├── 输入：读取外部信号（按键、传感器）
├── 输出：控制外部设备（LED、继电器）
└── 复用：作为其他外设引脚（USART、SPI、I2C）
```

![](./images/gpio工作模式.PNG)

#### 8 种工作模式

| 类型 | 模式 | 说明 |
|------|------|------|
| **输入** | 模拟输入 | ADC 采集 |
| | 浮空输入 | 高阻态，电平不确定 |
| | 上拉输入 | 内部上拉电阻 |
| | 下拉输入 | 内部下拉电阻 |
| **输出** | 通用推挽 | 可输出高低电平 |
| | 通用开漏 | 只能输出低电平，高电平需外接上拉 |
| | 复用推挽 | 外设控制，推挽输出 |
| | 复用开漏 | 外设控制，开漏输出 |



#### 推挽 vs 开漏

##### 推挽输出

输出0和1  要么高要么低  没有悬空

**工作原理**：

-  输出高电平（1）：“拉高大力士” (P-MOS)发力，把引脚主动接到 VCC，电流从 VCC→引脚→负载→GND（主动 “拉” 高）；
-  输出低电平（0）：“拉低大力士” (N-MOS)发力，把引脚主动接到 GND，电流从负载→引脚→GND（主动 “推” 低）；

##### 开漏输出

 输出0 不能输出1 （上拉电阻输出1 ）

**硬件结构**：内部只有一个 “拉低大力士”（NMOS 管，接 GND），没有 “拉高大力士”（VCC 端是 “断开的”，即 “开漏”）

**工作原理**：

- 输出低电平（0）：“拉低大力士” 发力，把引脚接到 GND（主动 “推” 低）；

- 输出高电平（1）：“拉低大力士” 松手，引脚悬空（不能主动拉到 VCC）—— 必须外接一个 “上拉电阻”（一端接 VCC），靠电阻把引脚 “被动拉高” 到 VCC；

  只能主动输出低电平，高电平靠外部上拉电阻实现 

  开漏可以读取外部数据 

   低电平上  推挽开漏一致，

| 特性             | 推挽输出 (Push-Pull)          | 开漏输出 (Open-Drain)                   |
| ---------------- | ----------------------------- | --------------------------------------- |
| **高电平输出**   | 直接输出                      | 需外接上拉电阻                          |
| **低电平输出**   | 直接输出                      | 直接输出                                |
| **主动输出能力** | 高、低都能主动输出            | 只能主动输出低，高靠外部上拉            |
| **驱动能力**     | 强（管子直接驱动，电流大）    | 弱（高电平靠电阻，电流受限制）          |
| **外部元件需求** | 无需额外电阻                  | 必须接上拉电阻（否则高电平无效）        |
| **线与功能**     | ❌ 不支持                      | ✅ 支持（核心优势，如 I2C 总线）         |
| **多设备并联**   | ❌ 不支持（会短路 VCC 和 GND） | ✅ 支持                                  |
| **电平匹配**     | 固定 VCC 电平（如 3.3V）      | 灵活（上拉接 5V 可输出 5V，跨电平通信） |
| **短路风险**     | ⚠️ 有                          | ✅ 无                                    |
| **常见别名**     | PP 输出                       | OD 输出、集电极开路（OC）               |
| **典型应用**     | LED、蜂鸣器驱动               | I2C、SMBus、One-Wire 总线               |

#### **STM32 IO口开漏输出和推挽输出有什么区别？**

（1）推挽输出既能输出低电平也能输出高电平，有比较强的电流驱动能力。

（2）开漏输出只能输出低电平，不能输出高电平。如果要输出高电平，需要外部接入上拉电阻。

需要读引脚电平 选开漏   

不需要 选推挽 

要强驱动、稳定电平、单向输出 （如 LED、SPI）→ 用推挽；

 **要多设备共享总线、跨电平通信、线与逻辑（如 I2C、中断并联）→ 用开漏（记得接外部上拉电阻）**



![输入模式](./images/输入模式.PNG)

- 外部信号是「低电平触发」且可能悬空 → 上拉输入（默认高，拉低有效）；
- 外部信号是「高电平触发」且可能悬空 → 下拉输入（默认低，拉高有效）；
- 外部信号「稳定且高速」（如串口、SPI） → 浮空输入（无电阻，快响应）。

| 输入模式     | 默认电平（悬空时） | 电阻配置                 | 稳定性 | 响应速度 | 核心适用场景                                          |
| ------------ | ------------------ | ------------------------ | ------ | -------- | ----------------------------------------------------- |
| **上拉输入** | 高电平 (1)         | 内部/外部电阻接 VCC      | 高     | 中等     | 按键检测、低电平触发的传感器                          |
| **下拉输入** | 低电平 (0)         | 内部/外部电阻接 GND      | 高     | 中等     | 高电平触发的传感器、避免高电平干扰                    |
| **浮空输入** | 不确定（乱跳）     | 无任何上拉/下拉电阻      | 低     | 快       | 高速信号接收（UART RX、SPI MISO）、外部信号稳定的场景 |
| **模拟输入** | -                  | 无数字电阻，直连模拟通道 | -      | -        | ADC 采集、模拟传感器、电池电压检测                    |



### 2.10 I2C 通信

**谈一下I2C总线**:



#### 基本概念

- **用途**：板内芯片间低速通信
- **特点**：同步、半双工、串行
- **速度**：100KHz（标准）、400KHz（快速）、3.4MHz（高速）

#### 硬件连接

| 信号线  | 功能   | 特点                   |
| ------- | ------ | ---------------------- |
| **SCL** | 时钟线 | 主机产生，同步数据传输 |
| **SDA** | 数据线 | 双向传输，半双工       |

#### 主从架构

- 一主多从
- 每个从机有唯一的 7 位/10 位设备地址  一位读写标志位

#### 协议信号

空闲状态：SCL和SDA均为高电平，接上拉电阻

启动信号：SCL保持高电平，SDA由高变低

数据位传送：SCL保持高电平，SDA保持稳定（低电平数据0，高电平数据1）

ACK应答信号：SCL保持高电平，SDA保持低电平

NACK非应答信号：SCL保持高电平，SDA保持高电平

停止信号：SCL保持高电平，SDA变高



```
时钟线SCL
    ─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌─┐  ┌──
     └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘
      ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑
     S   A6   A5   A4   A3   A2   A1   A0   R/W  ACK  D7   D6   D5   D4   D3   D2   D1   D0   ACK   P
    起始  设备地址(7位)        读/写  应答  数据(8位)                              应答  停止

数据线SDA
    ──┐        ┌────┐     ┌────┐  ┌──┐        ┌──┐  ┌────┐     ┌────────┐  ┌────┐
      └────────┘    └────┘     └──┘  └────────┘  └──┘     └────┘        └──┘    └────┘
      ↓        ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓
     SCL高    SCL低电平准备数据，SCL高电平采样
     SDA下降
     =Start

```



#### 写寄存器时序

```
Start → 发送设备写地址(0) → 等待 ACK → 发送寄存器地址 → 等待 ACK 
      → 发送数据 → 等待 ACK → Stop
```

#### I2C 使用开漏模式的原因

1. **防止短路**：多个设备共用总线时避免冲突   
2. **实现线与功能**：多主仲裁机制

#### 驱动验证方法

- 读取设备 ID 寄存器进行验证
- 使用逻辑分析仪查看波形和协议是否一致

#### 软件 IIC vs 硬件 IIC

| 特性 | 软件 IIC | 硬件 IIC |
|------|----------|----------|
| 实现方式 | GPIO 模拟 | 硬件外设 |
| CPU 占用 | 较高 | 较低 |
| 可移植性 | 高 | 低 |
| 开发难度 | 繁琐 | 简单 |

#### 上拉电阻选择

- 范围：1-10 千欧，常用 4.7 千欧  4.7kΩ
- 与速率关系：速率越快，电阻越小
- 原则：在不影响数据稳定性的前提下，电阻尽可能大

### 2.11 SPI 通信

#### 基本概念

- **用途**：板内芯片间高速通信
- **特点**：同步、串行、全双工
- **速度**：可达 50MHz

#### 硬件连接（4 线）

| 引脚 | 全称 | 功能 |
|------|------|------|
| CS | Chip Select | 片选信号 |
| MOSI | Master Out Slave In | 主出从入 |
| MISO | Master In Slave Out | 主入从出 |
| SCL | Serial Clock | 时钟线 |

#### 主从架构

- 一主多从
- 从设备数量由片选线决定

#### 协议特点

- **本质**：数据交换（发送同时接收）
- **数据格式**：MSB（高位先行）

#### 4 种工作模式

| 模式 | CPOL（极性） | CPHA（相位） | 说明 |
|------|-------------|-------------|------|
| 模式 0 | 0 | 0 | 空闲低电平，第 1 个边沿采样 |
| 模式 1 | 0 | 1 | 空闲低电平，第 2 个边沿采样 |
| 模式 2 | 1 | 0 | 空闲高电平，第 1 个边沿采样 |
| 模式 3 | 1 | 1 | 空闲高电平，第 2 个边沿采样 |

- **CPOL**：空闲时时钟电平（0=低，1=高）
- **CPHA**：采样边沿（0=第 1 个，1=第 2 个）

### 2.12 UART 通信

#### 基本概念

- **特点**：串行、全双工、异步
- **硬件**：Rx、Tx

#### 波特率

常用：115200、9600（误差 5% 以内可接受）

#### 数据帧格式

起始位 + 数据位 + 校验位 + 停止位

#### 如何保证接收数据正确？

奇偶校验方式

#### 如何接收不定长数据？

1. **约定方式**：接收特定字符（如 `\r\n`）代表一帧数据结束
2. **空闲中断**：STM32 提供的空闲中断功能

#### 应用场景

- 调试打印输出（printf 输出重定向）
- 与指纹模组发送 AT 指令
- 与 QS100 模块通信

### 2.13 RS485 vs RS232

| 特性 | RS485 | RS232 |
|------|-------|-------|
| 传输距离 | 1200m | 15m |
| 信号方式 | 差分信号（双线制） | 对地电压（单线） |
| 抗干扰能力 | 强 | 弱 |
| 通信模式 | 半双工、主从模式 | 全双工、点对点 |
| 应用场景 | 工厂、楼宇自动化 | 老式打印机、投影仪 |

### 2.14 CAN 总线 vs RS485

| 特性 | CAN 总线 | RS485 |
|------|----------|-------|
| 价格 | 较高 | 较便宜 |
| 抗干扰能力 | 较强（差分信号） | 较弱（差分信号） |
| 应用场景 | 机器人、车载 | 距离较远的场景 |

### 2.15 无线通信技术对比

| 技术 | 距离 | 连接数 | 速率 | 功耗 | 应用场景 |
|------|------|--------|------|------|----------|
| WiFi | 几十米 | 十几个 | 几百M | 高 | 联网 |
| 蓝牙 | 十几米 | 点对点 | 几十K | 比较低 | 耳机等 |
| 2.4G | 几百米 | 几十个 | 几M | 适中 | 遥控器 |
| LoRa | 几公里 | 数量多 | 几十K | 比较低 | 物联网 |
| NB-IoT | 十几公里 | 数量多 | 几十K | 比较低 | 物联网 |

### 2.16 定时器

rtc  滴答  看门狗 定时器



#### 基本概念

- 计数器：向上、向下、对齐计数
- 功能：输入捕获、输出比较、PWM 输出

#### PWM 占空比设置

```
占空比 (%) = (CCR / (ARR + 1)) × 100%
```

- CCR：比较寄存器值
- ARR：自动重装载寄存器值

### 2.17 DMAe

将外部捕获的数据传递给内存，**不占用 CPU 资源**。

### 2.18 ADC 采集 4-20mA 电流

- ADC 采集模拟信号
- 如果采集电压高于 3.3V，使用串联电阻分压 ，，

### 2.19 开发调试手段

- printf 输出 debug
- 逻辑分析仪
- 示波器
- 万用表

### 2.20 单片机上电代码没跑通的排查思路

1. **硬件问题**：焊接问题、元器件问题、板子损

1. **软件问题**：串口打印输出调试

**（1）*****\*供电：\****先使用电表测供电引脚电压是否正常。再检查是否有焊接上的问题。

**（2）*****\*复位释放：\****需要检查单片机复位引脚的状态，若处于复位状态，则需要考虑是不是外部复位电路元器件出现焊接或物料问题。

**（3）*****\*晶振：\****可以使用示波器或逻辑分析仪测试晶振引脚是否有震动周期信号的正常输出。

**（4）*****\*程序烧录：\****先检查下载程序界面是否提示下载成功，若成功还是程序没有运行，可以尝试重新烧录。

**（5）*****\*代码死循环：\****可以通过单步调试，来判断是否有循环，或者硬件内部存在bug，使得软件执行时卡死（STM32的硬件资源IIC，存在这种卡死问题）。



### 2.21 单片机上电代码没跑通的排查思路

**看门狗的作用，底层是怎么执行的？**

防止MCU死机。就是防止程序发生死循环,或者说程序跑飞。

基于一个自动计数器，‌该计数器在系统运行后启动。‌如果在一定时间内没有对看门狗进行清理操作，‌计数器会溢出，可选触发中断或系统复位。





### 2.21 STM32 低功耗模式





| 模式 | 特点 |
|------|------|
| **睡眠模式** | CPU 关闭，外设工作 (任意中断唤醒) |
| **停机模式** | CPU 关闭，外设关闭，内存和寄存器值保存 () |
| **待机模式** | 相当于复位（功耗最低） (rtc) |

**其他降功耗方法**：降低主频

---

## 三、FreeRTOS 实时操作系统

### 3.1 选择 FreeRTOS 的理由

| 优势 | 说明 |
|------|------|
| 开源免费 | 开源许可，无授权费用（也支持付费定制化） |
| 轻量级 | 代码量小，资源占用少 |
| 功能丰富 | 任务、信号量、队列、事件组等 |
| 应用广泛 | 社区活跃，文档丰富，资料齐全 |
| 可移植性强 | 支持多种处理器架构，API 好上手 |
| 低功耗支持 | 支持 Tickless 模式 |

### 3.2 FreeRTOS 移植

#### 需要的文件

- `port.c`：平台相关代码
- `task.c`：任务管理
- `heap.c`：内存管理文件
- `FreeRTOSConfig.h`：配置文件

#### 配置项

- 调度器类型（抢占式/时间片轮转）
- 时钟、主频
- 空闲任务开启
- 任务优先级、任务名称大小、空闲任务堆栈大小
- 屏蔽中断的优先级
- PendSV、SVC、SysTick 相关中断配置
- 堆空间大小
- 功能开关（信号量、事件组、任务通知等）

### 3.3 系统裁剪

#### 什么是裁剪？

根据项目需求，在 `FreeRTOSConfig.h` 中选择性地启用或禁用功能。

#### 为什么裁剪？

- 减少内存占用
- 降低系统开销
- 简化维护和配置

#### 可配置项

- 调度器类型（抢占式/协作式）
- CPU 频率
- 滴答（Tick）频率
- PendSV 和 SVC 中断优先级
- 堆内存大小
- 功能开关（信号量、事件组、任务通知等）

### 3.4 上下文切换

#### 是否需要切换？

在滴答中断中判断：

1. **遍历阻塞列表**：检查是否有阻塞到期的任务，将其移入就绪列表
2. **优先级检查**：从高优先级就绪列表开始遍历，发现有高于或等于当前优先级的任务则需要切换

#### 在哪切换？

在 **PendSV 中断** 中实现：

1. **保存上下文**：保存当前任务的寄存器状态（CPU中的状态）
2. **恢复上下文**：恢复要切换任务的寄存器状态

#### 切换流程

```
启动调度器 → SVC函数加载第一个任务 
         → 时间片结束/高优先级任务就绪 
         → 触发PendSV执行上下文切换 
         → 保存当前任务上下文 
         → 加载下一个任务上下文
```

### 3.5 任务调度策略

#### 抢占式调度

- **适用范围**：不同优先级任务之间
- **规则**：高优先级任务总是抢占低优先级任务
- **低优先级执行条件**：高优先级任务进入阻塞状态

**进入阻塞的方式**：
- **主动进入**：调用延时函数（`vTaskDelay`）
- **被动进入**：等待资源（信号量、队列等）

#### 时间片轮转调度

- **适用范围**：同优先级任务之间
- **规则**：按时间片轮流执行
- **时间片长度**：通常等于一个滴答周期

### 3.6 任务状态

| 状态 | 说明 |
|------|------|
| **运行态** | 正在执行的任务 |
| **就绪态** | 准备执行，等待调度 |
| **阻塞态** | 等待事件（延时、信号量等） |
| **挂起态** | 被显式挂起 |

> 挂起和阻塞：任务进入阻塞/挂起状态会从CPU调度队列中移除，暂时不占用CPU资源，加快其他任务运行效率。

### 3.7 空闲任务（Idle Task）

#### 作用

1. **系统必需**：系统至少需要一个可运行的任务
2. **资源回收**：回收自杀任务（删除自身）的资源
3. **低功耗**：可配置进入低功耗模式

### 3.8 任务优先级

- **数量**：默认支持 32 个优先级（0-31），可通过宏配置
- **数值越大优先级越高**
- **优先级 0**：空闲任务专用

#### 任务优先级和中断优先级的关系

没有关系，互不干扰。

#### 优先级设置原则

根据任务重要性分配：

| 任务类型 | 优先级建议 |
|----------|-----------|
| 硬件读取（如传感器） | 高 |
| 通信任务 | 中 |
| 显示/UI 任务 | 低 |

### 3.9 优先级翻转

#### 问题描述

高优先级任务等待低优先级任务持有的资源，而中优先级任务抢占低优先级任务，导致高优先级任务长时间等待。

```
低优先级任务持有信号量
高优先级任务等待该信号量 → 被阻塞
中优先级任务抢占低优先级任务
高优先级任务无法获得执行机会
```

#### 解决方案

使用**互斥信号量（Mutex）**，启用**优先级继承机制**：
- 当低优先级任务持有互斥量时，临时将其优先级提升到等待该资源的高优先级任务的优先级

### 3.10 临界区

#### 本质

关闭中断，防止任务切换。

#### 特点

- **可嵌套**：支持多次进入和退出
- **尽量简短**：避免长时间关闭中断

```c
taskENTER_CRITICAL();    // 进入临界区
// 临界代码（原子操作）
taskEXIT_CRITICAL();     // 退出临界区
```

### 3.11 任务间通信机制

| 机制 | 用途 |
|------|------|
| **队列（Queue）** | 任务间数据传输 |
| **信号量（Semaphore）** | 任务同步和资源管理 |
| **互斥量（Mutex）** | 互斥访问共享资源 |
| **事件组（Event Group）** | 多事件同步 |
| **任务通知（Task Notification）** | 轻量级同步 |
| **流缓冲区/消息缓冲区** | 单生产者单消费者快速传输 |
| **环形缓冲区** | 高效数据缓存 |
| **队列集** | 同时等待多个队列 |

### 3.12 信号量类型

| 类型 | 特点 | 用途 |
|------|------|------|
| **二值信号量** | 0 或 1 | 任务同步（可能导致优先级翻转） |
| **计数信号量** | 0 到 N | 资源计数 |
| **互斥信号量** | 带优先级继承 | 互斥访问，解决优先级翻转 |

### 3.13 任务通知

- **特点**：最轻量级的同步机制，无需创建额外对象
- **限制**：每个任务最多 32 个通知值
- **优势**：不需要占用额外的内存空间，使用 TCB 结构体存储任务通信值（4字节）

### 3.14 死锁

#### 定义

两个或多个任务互相等待对方持有的资源，导致永久阻塞。

```
任务 A 持有资源 1，请求资源 2
任务 B 持有资源 2，请求资源 1
```

#### 处理

- **预防**：按固定顺序申请资源
- **解决**：一旦出现，无解，只能重启系统

### 3.15 内存管理机制

| 方案 | 特点 | 适用场景 |
|------|------|----------|
| **Heap_1** | 只申请不释放，无碎片 | 任务不删除的系统 |
| **Heap_2** | 可申请释放，不合并相邻块，有碎片，采用 best 算法 | 简单应用 |
| **Heap_3** | 封装标准 `malloc/free`，线程安全 | 已有成熟内存管理 |
| **Heap_4** | 申请释放，合并相邻空闲块，采用 fast 算法 | 推荐，最常用 |
| **Heap_5** | 申请释放，合并相邻和不相邻块，支持非连续内存 | 多内存区域系统 |

### 3.16 低功耗实现

当用户任务都进入阻塞/挂起状态时进入空闲任务：

1. 根据期望睡眠时间，修改 SysTick 的重装载值
2. 任务进入睡眠期间（不会有中断打扰）
3. 等待 SysTick 中断，调用 WFI 指令自动唤醒
4. 补偿系统滴答值

### 3.17 常见问题排查

#### 内存溢出、堆栈溢出问题

1. **开启堆栈监视功能**
2. **使用 `vTaskList()` 函数**：输出所有任务的状态列表，包括堆栈最高水位线
3. **配置 `configCHECK_FOR_STACK_OVERFLOW`**：任务堆栈溢出检查配置

---

## 四、Linux 基础

### 4.1 进程间通信

| 方式 | 说明 |
|------|------|
| **管道** | 两个进程间的单向通信 |
| **共享内存** | 共享内存，需注意读写顺序，配合二值信号量 |
| **消息队列** | 内核提供的队列，本质是一个文件 |
| **信号量** | 与线程信号量通信一致 |
| **Socket** | socket() 绑定IP和端口 → connect() 连接 → send() 发送 → close() 关闭 |

### 4.2 常用命令

| 命令 | 功能 |
|------|------|
| `mv` | 移动/重命名 |
| `cp` | 复制 |
| `mkdir` | 创建目录 |
| `free -m` | 查看系统剩余内存 |
| `ps -ef` / `ps -aux` | 查看进程 |
| `netstat -tunlp \| grep 端口号` | 查看端口 |
| `tar -zxvf 压缩包 -C 路径` | 解压 |
| `du -sh` | 查看磁盘 |
| `find` | 查找文件 |

### 4.3 一切皆文件

Linux 中一切皆文件：
- 进程
- 硬件资源
- 网络资源
- 内存资源
- 队列、共享内存

文件系统：要么是文件，要么是文件夹

---

## 五、项目开发流程

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  市场调研    │ ──→ │    立项     │ ──→ │  明确需求    │
└─────────────┘     └─────────────┘     └──────┬──────┘
                                                │
┌─────────────┐     ┌─────────────┐            │
│  大批量生产  │ ←── │  小批量生产  │ ←───┬──────┘
└─────────────┘     └─────────────┘     │
                                        ↓
                               ┌─────────────┐
                               │   软件研发   │
                               │   硬件研发   │
                               └──────┬──────┘
                                      ↓
                               ┌─────────────┐
                               │    测试     │
                               └─────────────┘
```

### 复习重点

- **硬件**：原理图、芯片选型、接口定义
- **软件**：架构设计、模块划分、通信协议
- **串讲**：项目整体流程、关键问题解决

---

## 六、项目实战

### 6.1 小智 AI 语音聊天机器人

#### 项目背景

一款 AI 语音聊天机器人，支持语音交互和智能回复，可以进行日常聊天和设备操控（如查询天气、调节音量）。

#### 硬件配置

| 组件 | 型号 | 参数 | 通信方式 |
|------|------|------|----------|
| 主控 | ESP32-S3 | 主频 240MHz，内存 512KB，Flash 8MB，外扩 SPIRAM 8MB | - |
| 音频编解码 | ES8311 | - | I2C + I2S |
| 功放 | NS4105B | 模拟音频信号放大 | - |
| 屏幕 | ST7789V | 320×240 分辨率 IPS | SPI |

#### 软件架构

##### 1. 智能配网

| 方式 | 技术 |
|------|------|
| 低功耗蓝牙 | BLE 配网 |
| WiFi 配网 | 热点 + HTTP Server |

##### 2. 数据流程

**上行流程（录音上传）**：

```
麦克风采集 → ES8311 ADC → Feed 任务读取 PCM → SR 模型识别 
         → Fetch 任务获取识别结果 → Opus 编码 → WebSocket 上传服务器
```

**下行流程（播放回复）**：

```
WebSocket 接收音频 → Opus 解码成 PCM → ES8311 DAC → 扬声器播放
```

##### 3. 状态机

语音识别状态、唤醒状态、睡眠状态的切换，使用全局标志位实现。

##### 4. 屏幕显示（LVGL）

- WiFi 信号强度（20号字模）
- 设备状态
- 通话语音内容（30号字体）
- 表情包动画（64号字体）

##### 5. 回调函数类型

| 类型 | 说明 |
|------|------|
| **STT** | Sound To Text，显示识别的文字 |
| **TTS** | Text To Sound，包含 start、sentence_start、stop |
| **LLM** | AI 回复表情包显示 |
| **IOT** | 根据 JSON 字符串执行硬件控制（回调函数名 + 参数） |

---

### 6.2 智能门铃

#### 项目背景

智能家居子项目，实现门铃 + 电子猫眼功能。

#### 系统组成

- **室外机**：摄像头、麦克风、按键
- **室内机**：显示屏、扬声器
- **APP 端**：远程查看、对讲
- **WebSocket 服务器**：信令中转
- **MQTT 服务器**：消息推送

#### 硬件配置

| 组件 | 型号 | 通信方式 |
|------|------|----------|
| 主控 | ESP32-S3 | - |
| 音频编解码 | ES8311 | I2C + I2S |
| 功放 | NS4105B | - |
| 摄像头 | OV2640 | I2C + DVP |

#### 软件功能

##### 1. 配网流程

首次启动使用 ESP-IDF 配网 API（BLE 方式）：
1. 建立蓝牙连接
2. 接收 WiFi 配置信息
3. 保存配置信息
4. 连接 WiFi
5. 向 MQTT topic-A 发送 Ready 数据
6. 订阅 topic-B 接收后续指令

##### 2. 按铃流程

1. 通过 LoRa 向室内接收器发送通知 → 接收器响铃
2. 向 MQTT 服务器推送消息 → APP 收到通知
3. 主机本身响铃（反馈访客）

##### 3. 音视频通话

1. APP 向 MQTT 发送开启摄像头和麦克风指令
2. 主机收到指令后开始收集摄像头和麦克风数据
3. 将数据推送到 WebSocket 服务器
4. APP 获取门外音视频数据
5. APP 麦克风数据通过 WebSocket 推送到主机 → 扬声器播放

##### 4. OTA 升级

- 创建专用 OTA 任务，平时阻塞等待通知
- APP 检测新版固件后发送 OTA 指令
- 调用 `esp_https_ota` 下载固件
- 下载成功后调用 `esp_restart` 重启

**分区表**：ota_0 + ota_1 + ota_data

---

### 6.3 智能门锁

#### 项目背景

智能家居子项目，替代传统机械门锁。

#### 硬件配置

| 组件 | 型号 | 通信方式 | 说明 |
|------|------|----------|------|
| 主控 | ESP32-C3 | - | 主频 160MHz，内存 400KB，Flash 4MB |
| 触摸按键 | SC12B | I2C | 支持 12 个触摸按键 |
| 指纹模块 | FPM383 | 串口 | 自定义数据格式，容量 50 枚 |
| 语音模块 | WTN6170 | 一线串口 | 语音提示 |
| 全色灯 | WS2812 | RMT 驱动 | 一线串口 |
| 电机驱动 | BDR6120 | GPIO | 内置 MOS 管 |

#### 软件功能

##### 1. 开锁方式

| 方式 | 实现 | 细节 |
|------|------|------|
| **密码开锁** | 输入密码匹配 | 以 `#` 结束，支持防偷窥（前后可输入随机数字） |
| **指纹开锁** | FPM383 验证 | 一站式验证指令，自动感应 |
| **蓝牙开锁** | BLE 通信 | 首次需配对码，之后自动连接 |
| **远程开锁** | MQTT / 临时密码 | 方案1：MQTT 实时指令；方案2：基于时间戳的临时密码算法 |

##### 2. 密码管理

| 操作 | 流程 |
|------|------|
| **添加密码** | 输入管理员密码 → 验证 → 输入新密码两次 → 存储到 NVS |
| **删除密码** | 输入管理员密码 → 验证 → 输入要删的密码两次 → 从 NVS 删除 |

##### 3. 指纹管理

| 操作 | 流程 |
|------|------|
| **添加指纹** | 输入管理员密码 → 发送添加指令 → 按压手指多次 → 存储到模组（容量50枚） |
| **删除指纹** | 输入管理员密码 → 发送删除指令 → 指定 ID 删除 |

##### 4. OTA 升级

- 自定义分区表：2 个 OTA 应用分区 + 1 个数据分区
- 使用 `esp_https_ota` 组件

##### 5. 低功耗设计

| 组件 | 进入低功耗 | 退出低功耗 |
|------|-----------|-----------|
| ESP32-C3 | DFS + Light Sleep | 事件唤醒 |
| SC12B | 75 秒无按键且 SDA 高电平 | 检测到按键自动退出 |
| FPM383 | 发送 Sleep 指令 | 手指按压自动退出 |
| WTN6170 | 播放完成 2 秒后 | 播放指令唤醒 |
| WiFi | 随用随开 | - |
| 蓝牙 | BLE 模式 | - |

##### 6. 电机堵转保护

检测电流或编码器反馈，发现堵转立即停止并报警。

---

### 6.4 无人机飞控

#### 项目背景

儿童玩具无人机，实现稳定飞行和遥控功能。

#### 硬件配置

##### 飞控端

| 组件 | 型号 | 参数 | 通信 |
|------|------|------|------|
| 主控 | STM32F103C8T6 | 主频 72MHz，内存 20KB，Flash 64KB | - |
| 姿态传感器 | MPU6050 | 6 轴（3 轴加速度 + 3 轴角速度） | I2C（400KHz） |
| 激光测距 | VL53L1X | 测距范围 30cm-4m | I2C |
| 2.4G 通信 | SI24R1 | - | SPI |
| 电源芯片 | IP5305T | 充放电管理 | - |

##### 遥控端

| 组件 | 型号 | 说明 |
|------|------|------|
| 主控 | STM32F103C8T6 | 同飞控 |
| 2.4G 通信 | SI24R1 | SPI |
| 摇杆 | 电位器 | ADC 采集 |
| OLED | 128x64 | 显示 LOGO、信道、电量 |
| 电源芯片 | IP5305T | - |

#### 软件架构

##### 飞控软件（FreeRTOS）

**为什么上 RTOS？**

裸机轮询方式的问题：
```c
// 裸机方式：难以保证实时性
int cnt = 0;
// 定时器中断: cnt++
while (1) {
    if (cnt % 2 == 0)  read_sensor();
    if (cnt % 4 == 0)  control_motor();
    // ... 代码耦合度高，难以维护
}
```

**任务划分**：

| 任务 | 功能 | 优先级 |
|------|------|--------|
| **飞控任务** | 姿态解算 + PID 控制 | 最高 |
| **通信任务** | 接收遥控数据 | 高 |
| **灯控任务** | LED 状态指示 | 低 |
| **电源任务** | 电量检测与关机控制 | 中 |

**飞控算法流程**：

```
1. 读取 MPU6050 六轴数据
        ↓
2. 零偏校准（去除静态误差）
        ↓
3. 滤波处理
   ├── 角速度：一阶低通滤波（a * 上次值 + (1-a) * 本次值）
   └── 加速度：卡尔曼滤波
        ↓
4. 四元数解算 → 欧拉角（Pitch、Roll、Yaw）
        ↓
5. 串级 PID 控制
   ├── 外环：角度环（目标角度 - 实际角度）
   └── 内环：角速度环（外环输出作为目标角速度）
        ↓
6. PID 输出 → 电机 PWM

定高控制（额外）：
   ├── 读取 VL53L1X 高度
   ├── 速度计算（高度差/时间 + 加速度积分）
   ├── 互补滤波融合
   └── 串级 PID（外环高度 → 内环 Z 轴速度）
```

##### 遥控软件

| 模块 | 功能 |
|------|------|
| **按键扫描** | 检测按键状态 |
| **摇杆扫描** | ADC 读取 → 极性调整 → 范围映射 → 封装结构体 |
| **通信模块** | 打包发送数据到飞控 |
| **显示模块** | OLED 显示信道、电量、摇杆值 |

**通信协议（18 字节）**：

| 字段 | 长度 | 说明 |
|------|------|------|
| 帧头 | 3 字节 | 同步标识 |
| 载荷长度 | 1 字节 | 数据长度 |
| 载荷 | 10 字节 | 摇杆数据（油门、偏航、俯仰、横滚） |
| 校验和 | 4 字节 | CRC32 |

**信道确定机制**：

| 端 | 策略 |
|---|------|
| 飞控 | `hash(芯片 ID) % 126 + 1` |
| 遥控 | 从 1 开始扫描，连接成功保存，下次直接使用 |

**电源管理**：

- 低负载 20 秒自动关机
- 飞控定期发送心跳防止关机
- 支持远程关机（两次短按模拟）

---

### 6.5 牛羊定位器

#### 项目背景

智慧农业子项目，实现牛羊位置追踪和运动量监测。

#### 硬件配置

| 组件 | 型号 | 通信 | 说明 |
|------|------|------|------|
| 主控 | STM32F103C8T6 | - | 主频 72MHz（实际使用 8MHz），内存 20KB |
| GPS 模块 | AT6558R | 串口 | 支持北斗 + GPS 多模定位 |
| NB-IoT | QS100 | 串口 | AT 指令，低功耗广域网 |
| 计步传感器 | DS3553 | I2C | 内置 8 位 CPU，预计算步数 |
| LoRa | LLCC68 | SPI | 远距离低功耗通信 |

#### 软件架构

**开发方式**：裸机开发（简单业务逻辑，无需 RTOS）

**业务流程**：

```
读取 GPS 数据 ──┐
              ├──→ 封装 JSON → NB-IoT 上传云端
读取步数数据 ───┘
                  ↓
            NB 无信号时 → LoRa 发送给网关
```

#### 低功耗设计

| 组件 | 低功耗模式 | 唤醒方式 |
|------|-----------|---------|
| STM32F103 | 待机模式（Standby） | 闹钟中断 |
| QS100 | PSM 模式 | 唤醒引脚高电平 100ms-5s |
| GPS | 断电 | 重新上电 |
| DS3553 | 静止 15s 自动进入 | 检测到运动自动退出 |
| LoRa | 睡眠模式 | 定时唤醒 |

**电池**：锂亚电池，容量 9000mAh，可工作约一年

---

### 6.6 STM32 网关

#### 项目背景

为不具备联网能力的设备提供联网能力，支持多种通信协议。

#### 硬件配置

| 组件 | 型号 | 通信方式 | 说明 |
|------|------|----------|------|
| 主控 | STM32F103C8T6 | - | 支持串口、SPI、CAN，成本低 |
| RS485 模块 | MAX13487EESA+ | 串口 | Modbus-RTU 协议 |
| CAN 模块 | PD1050S | CAN | 自定义协议 |
| LoRa 模块 | LLCC68 | SPI | 远距离通信 |
| 以太网模块 | W5500 | SPI | MQTT 协议 |
| NB-IoT | QS100 | 串口 | AT 指令 |

#### 软件架构

##### 任务划分

| 任务 | 功能 |
|------|------|
| **网络任务** | MQTT 连接，上传数据到云服务器，获取远端命令 |
| **RS485 处理任务** | 封装协议帧，下发指令，接收响应 |
| **LoRa 处理任务** | LoRa 通信，自定义协议 |
| **CAN 处理任务** | CAN 通信，差分信号收发 |

##### 协议格式

**Modbus-RTU**：
```
设备地址(1字节) + 功能码(1字节) + 数据(N字节) + CRC校验(2字节)
```

**LoRa 自定义协议**：
```
帧头校验 + 命令内容 + 帧尾校验

命令类型：启动停止、转向、转速控制
```

**CAN**：使用报文 ID 标识电机和网关

---

### 6.7 步进电机控制

#### 电机选型

- **类型**：混合式步进电机
- **规格**：两相四线双极性驱动，200步/圈，每步 1.8°
- **结构**：定子 48 齿（8组线圈），转子 50 齿（永磁体）
- **驱动芯片**：东芝 TB 驱动芯片，支持细分（1/4步分辨率）

#### 控制原理

**转动原理**：通过交替改变 A 相和 B 相电流方向，控制转子受力。转子每次转动 1/4 齿，即 200 次转一圈。

**细分控制**：1/4 步分辨率，给驱动芯片发送 4 个脉冲 = 电机转一步 = 800 个脉冲转一圈

#### 速度和步数控制

**速度控制**：控制发送脉冲的频率（STM32 定时器比较输出）

**步数控制**：在定时器比较中断中计数，每两个中断记录一步

#### 加减速算法

| 算法 | 特点 |
|------|------|
| **梯形算法** | 加速度恒定，加速和减速阶段匀变速 |
| **S 形算法** | 加速度先增后减，曲线更平滑 |
| **增量式 PID** | 需配合光电编码器，实现闭环控制 |

#### 编码器

- **规格**：1000 线光电编码器
- **四倍频**：AB 相同时采集变化沿，转一圈采集 4000 个信号

#### 适用场景

低转速、低负载场景。高转速可能导致堵转和丢步。

---

## 附录

### 常用缩写对照

| 缩写 | 全称 | 中文 |
|------|------|------|
| ADC | Analog-to-Digital Converter | 模数转换器 |
| DAC | Digital-to-Analog Converter | 数模转换器 |
| PWM | Pulse Width Modulation | 脉冲宽度调制 |
| I2C | Inter-Integrated Circuit | 集成电路总线 |
| SPI | Serial Peripheral Interface | 串行外设接口 |
| UART | Universal Asynchronous Receiver/Transmitter | 通用异步收发传输器 |
| GPIO | General Purpose Input/Output | 通用输入输出 |
| RTOS | Real-Time Operating System | 实时操作系统 |
| BLE | Bluetooth Low Energy | 低功耗蓝牙 |
| NVS | Non-Volatile Storage | 非易失性存储 |
| OTA | Over-The-Air | 空中升级 |
| PID | Proportional-Integral-Derivative | 比例-积分-微分控制 |
| MQTT | Message Queuing Telemetry Transport | 消息队列遥测传输协议 |
| DMA | Direct Memory Access | 直接内存访问 |

---

*整理时间：2025年*
